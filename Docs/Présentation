<center>
![Logo de WebCpp](http://www.webcpp.org/images/webcpp-logo.png)
WebCpp : développez vos sites Web en C++ !
</center>

Bonjour,

Aujourd’hui, je vais vous présenter un projet sur lequel je travaille seul depuis environ deux ans, bien qu’il y ait eu des pauses plus ou moins longues. Il s’agit d’un projet de taille importante et je dois reconnaître qu’il y a beaucoup de choses à dire et j’ai plutôt tendance à rentrer dans les détails rapidement ! J’espère que vous trouverez ce projet suffisamment intéressant pour lire sa présentation jusqu’au bout.

# À propos de moi #

Mais tout d’abord qui suis-je ? Je m’appelle Kévin Lesénéchal et j’ai 21 ans, je suis membre du Site du Zéro depuis avril 2006 (déjà !). Bien que je n’ai pas été un membre très actif, autant sur le forum qu’en termes de tutoriels, j’ai été un visiteur très régulier pendant toutes ces années. C’est le Site du Zéro qui m’a permis de découvrir ma passion : l’informatique, plus spécifiquement le développement (autant logiciel que Web). J’ai commencé par le classique XHTML / CSS / PHP / MySQL pour finalement m’orienter vers le C puis le C++ quand le cours est sorti (l’attente fut longue !). Je me suis également intéressé à GNU/Linux, une expérience qui m’a profondément changé. J’ai totalement adhéré à la philosophie du logiciel libre ce qui m’a permis de réellement voir la beauté de ce système sur lequel je tourne depuis au moins 4 ans. J’ai débuté avec Ubuntu puis je me suis tourné vers Arch Linux, qui me convient mieux et que je recommande chaudement !

J’ai découvert le Site du Zéro alors que j’étais encore au collège (en 4è si mes souvenirs sont bons !) et ma nouvelle passion a commencé à déborder sur ma scolarité (et mon sommeil !)… C’est pourquoi j’ai échoué ma seconde générale, je me suis alors rabattu sur un BEP en électronique. Mes préjugés à propos du lycée professionnel se sont très vite dissipés et j’ai repris goût à l’école ! Après mon BEP j’ai poursuivi sur un Bac Pro SEN (systèmes électroniques et numériques), obtenu avec mention très bien (attention !). À partir de là j’ai dû quitter mon archipel pour la métropole pour mes études. En effet je suis originaire de Saint-Pierre-et-Miquelon, un tout petit DOM/TOM en Amérique du Nord, près du Canada. Je suis donc parti pour Paris pour étudier à l’école EPITECH, je suis actuellement en deuxième année.

# WebCpp, c’est quoi ? #

C’est tout me concernant ! Voyons voir ce que j’ai pour vous aujourd’hui… Un framework de développement Web… en C++. Vous avez bien entendu, j’ai placé les mots « Web » et « C++ » dans la même phrase. WebCpp rend cette association possible : il est un framework, codé en C++, vous permettant de développer des sites Web dans le langage C++ (côté serveur, évidemment). En soit, il remplace le PHP et d’autres langages courants dans le Web (Python, Ruby, Java, …). Cela reste une association surprenante, le C++ semble être un langage tout à fait inadapté à la réalisation de sites Web ! Mais alors pourquoi ? Pourquoi voudrait-on utiliser ce langage dans ce contexte ? La réponse est simple : les performances.

# Pourquoi le C++ ? #

En termes de performances, la différence entre le PHP et le C++ est très nette ! Nous avons d’un côté un langage interprété et de l’autre un langage compilé en un binaire natif directement exécuté par le processeur. Surtout que dans la famille des langages interprétés, PHP est plutôt mauvais élève en ce qui concerne la rapidité d’exécution ; d’autres langages interprétés comme Python sont bien plus rapides. Mais est-ce réellement un problème ?

Prennons un premier exemple : Wikipédia. Site à très fort traffic aux bases de données bien remplies. Si vous regardez [l’architecture serveur derrière Wikipédia](http://upload.wikimedia.org/wikipedia/commons/d/d8/Wikimedia-servers-2010-12-28.svg), vous remarquerez qu’il y a bien plus de serveurs Apache/PHP que de serveurs MySQL ! En effet, j’ai longtemps cru que le goulot d’étranglement des performances d’un site Web se situait au niveau de la base de données et que les scripts ne jouaient qu’un rôle secondaire. Un [article reprennant l’exemple de Wikipédia](http://blog.cppcms.com/post/42), m’a fait réaliser que j’avais tord. Un deuxième exemple : Facebook. Le célèbre réseau social, écrit en PHP, a développé une technologie baptisée HipHop : un compilateur transposant le PHP en C pour le compiler.

Il y a une réelle nécessité d’optimiser l’exécution des pages Web en dehors de la base de données. Les bénéfices que l’on en tire sont multiples : premièrement, les coûts en infrastructure serveur sont diminués, on a pas besoin de devoir acheter sans cesse de nouveaux serveurs toujours plus puissants et chers. Mais ce n’est pas tout, offrir à vos visiteurs un site Web plus rapide et réactif vous rapportera. Une étude menée par SmartBear a démontré que sur un site de e-commerce, 1 seconde de chargement supplémentaire entraîne 11 % de pages vues en moins entraînant une baisse de 7 % du chiffre d’affaire.

# Mode de fonctionnement #

Mais comment WebCpp y parvient-il ? Et comment peut-on même coder un site Web en C++ ? Certains d’entre vous ont pu entendre parler de CGI : une interface par laquelle le serveur HTTP exécute un programme pour générer une page Web, ce programme peut être un programme écrit en C, C++ ou n’importe quel autre langage. Celui-ci reçoit les informations sur la requête (URL, cookies, en-têtes, etc.) via l’environnement puis écrit sur sa sortie standard la page générée. WebCpp n’utilise pas CGI. Le problème de CGI est le même qu’avec PHP : le programme est instancié à chaque requête et à chaque requête le programme est lancé, s’initialise (charge la configuration, initie une connexion à un DBMS, etc.), traite la requête puis se ferme. Il est inacceptable que le programme s’initialise et se ferme à chaque requête.

## FastCGI : le lien entre WebCpp et le serveur HTTP ##

WebCpp utilise FastCGI : nous ne lançons qu’une seule instance du programme, qui s’initialise qu’une seule fois puis va entrer dans une boucle d’exécution infinie en attente de connexions entrantes. Avec FastCGI, WebCpp devient serveur (il attend des connexions, ici des requêtes) et le serveur HTTP (Apache / nginx / …) devient client : c’est le serveur HTTP qui se connecte à WebCpp (via FastCGI) pour demander l’exécution d’une requête. Dès que WebCpp reçoit une requête, celle-ci est immédiatement traitée et il passe à la suivante. L’exécution de la requête ne nécessite aucune initialisation : tout a déjà été initialisé par WebCpp avant même l’exécution de la première requête. Ce qui fait de WebCpp un daemon. Le gain en performances est terrible.

Mais alors comment développe-t-on des sites Web avec WebCpp ? N’oublions pas qu’il s’agit de C++ : à la différence avec des langages de scripts comme PHP ou Python, le C++ doit être compilé avant d’être utilisable. C’est pourquoi il y a une nette séparation entre la partie source de votre site Web (sources que l’on trouve sur les machines des développeurs) et la partie binaire, seule présente sur le serveur de production. En effet, il n’y a aucun fichier source C++ sur le serveur, aucun ! Il n’y a que des binaires. Les développeurs, qui possèdent les sources, compilent leur code en binaires pour les uploader sur le serveur. Évidemment, ils les auront testés sur leur propre machine avant de l’envoyer sur le serveur de production, cela va de soi.

Mais quels sont ces binaires que l’on doit compiler ? Premièrement, et non des moindres, il faudra compiler le seul (et unique !) exécutable : WebCpp lui-même. En effet, pour des raisons pratiques et idéologiques, WebCpp n’est distribué que sous forme de sources, c’est à l’utilisateur de le compiler. Cet exécutable est le framework lui-même, il ne s’agit pas d’une bibliothèque, même si elle se comporte comme tel. C’est cet exécutable que vous lancez qui est le daemon WebCpp et qui va charger des plugins sous la forme de fichiers `.so`. C’est dans ces plugins que vous allez écrire le code de votre site Web, votre code ne contiendra jamais de main() : c’est WebCpp qui appelle votre code, pas l’inverse. Vous aurez un fichier `.so` par module (forum, news, MP, admin, etc.) ainsi qu’un binaire général à votre site (`Site.so`). WebCpp est donc totalement agnostique de comment vous organiser vos sources.

## Caractéristiques générales ##

  * Seul l’UTF-8 est supporté et autorisé pour des raisons pratiques et de sécurité. N’utilisez jamais un quelconque autre encodage avec WebCpp : vous aurez systématiquement des problèmes d’encodage et causerez même des problèmes de sécurité. WebCpp est conçu pour exploiter uniquement l’UTF-8 et met en place des mécanismes de sécurité qui détectent et suppriment les séquences UTF-8 invalides. En effet, il est possible de réaliser certaines attaques par le biais de séquences UTF-8 invalides, peu de gens sont au courant de tels failles ; WebCpp est protégé contre celles-ci.
  * WebCpp ne travaille en interne qu’avec des heures UTC, uniquement ! Précisez toujours les heures en UTC, jamais en heure locale. Les heures UTC ne sont converties en heures locales qu’au tout dernier moment : à l’affichage, dépendamment du fuseau horaire de l’utilisateur. Ne vous souciez jamais des heures locales, WebCpp s’en charge, souciez-vous uniquement des heures UTC.
  * WebCpp ne fonctionne pas sous Windows !

# Exemple de page Web simple #

Prenons l’exemple d’une page Web simple générée avec WebCpp : nous afficherons une liste d’utilisateurs récupérée depuis une base de données. À l’heure actuelle, les mécanismes d’accès à une base de données restent bas-niveau, il n’y a pas encore d’ORM. Tout d’abord, voici un contrôleur contenant l’action « `displayDemo` » qui sera déclenchée pour cette page :

	#include <Controller>
	
	class MyController : public Controller
	{
		CONTROLLER(MyController)
	public:
		MyController()
		{
			registerAction(MyController::displayDemo);
		}
	
	private:
		void displayDemo()
		{
			View view = tpl("Demo.html"); // Nous récupérons notre template « Demo.html » (voir après)
			view["foo"] = "bar"; // Exemple d’affection de variable template
			
			// Nous exécutons la requête SQL, la liste des entrées est placée dans une variable template
			view["users"] = query("SELECT id, firstName, lastName, email FROM users;");
			
			view->render(); // Exécute le rendu du template
		}
	};

L’action est simple : nous récupérons un template, nous lui affectons deux valeurs dont une est la liste des utilisateurs récupérée depuis la base de données. Voyons voir à quoi pourrait ressembler ce template (fichier « `Demo.html` ») :

## Le moteur de templates ##

	{{inherit ::Layout.html}}
	{{block title}}Liste des utilisateurs{{/block}}
	{{block body}}
	<p>Exemple de variable : {foo} (de type « {typeof foo} » de {#foo} caractères).</p>
	<p>Exemple de calcul : {8 * ((foo == 'bar' && #users > 0 ? 2 : -8) + pow(10, 4)) / 4.2}</p>
	<table>
		<tr>
			<th>ID</th>
			<th>Nom</th>
			<th>Email</th>
		</tr>
	{{for i -> user in users}}
		<tr class="{{if i % 2 == 0}}even{{else}}odd{{/if}}">
			<td>{user.id}</td>
			<td>{user.firstName} {user.lastName|upper}</td>
			<td>{user.email|mailTo}</td>
		</tr>
	{{/for}}
	</table>
	{{/block}}

Le moteur de templates est l’un des composants les plus complexes de WebCpp mais aussi le plus puissant ! Les templates sont pris très au sérieux avec WebCpp car c’est un élément sur lequel on passe beaucoup de temps et ceux-ci doivent être flexibles et pratiques pour une meilleure productivité, qualité générale et même sécurité.

Un template exploite deux éléments : les blocs (entre doubles accolades, e.g. `{{if age >= 18}}…{{/if}}`) qui ressemblent aux balises HTML dans le sens où ceux-ci peuvent avoir un corps (e.g. `{{if cond}}corps{{/if}}`) ou pas (e.g. `{{include 'foo.html'}}`). Le deuxième élément constitutif sont les expressions, entre simples accolades (e.g. `{user.lastName|upper}`), qui sont parsées et évaluées grâce à un lexeur / parseur LL mis au point spécifiquement pour cette application. Les expressions prennent en compte les litérales (strings, nombres, tableaux litéraux, maps litérales), les variables, fonctions, filtres (analogues à des méthodes sur objet) et opérateurs.

Les expressions, lors de leur compilation, passent par un système d’optimisation puis de vérification de l’AST (l’arbre syntaxique abstrait, issu de la compilation) afin de détecter des erreurs *at compile-time* et de procéder à des optimisations. Par exemple, l’expression `age + 8 * pow(10, 2)` sera optimisée en `age + 800`, car nous appelons une fonction `pow` qui se déclare **sans effet de bord** (c’est-à-dire qu’elle retournera **toujours** le même résultat avec les mêmes paramètres **et** qu’elle n’interagit pas avec l’extérieur) et que tous ses paramètes sont constants (car ici des litérales). Par conséquent, le résultat de la fonction `pow` peut être calculé à la compilation et le résultat placé en dur comme constante pour économier un appel de fonction. Ensuite, la même optimisation s’applique avec `8 * 100` (le résultat de `pow`), l’opérateur `*` est sans effet de bord et ses opérandes sont constantes, par conséquent le résultat est précalculé.

À l’heure actuelle, chaque template est compilé une seule fois et l’objet de la compilation (l’AST) est placé en mémoire vive afin que celui-ci puisse être exécuté le plus rapidement possible à chaque fois que nécessaire. Le maximum de tâches est donc réalisé lors de la compilation qui peut être aussi lente qu’on le souhaite puisqu’elle n’intervient qu’une seule fois. Le point critique c’est l’exécution qui s’effectue à chaque requête. Il est prévu dans une version future d’ajouter une étape supplémentaire à l’optimisation de l’AST : l’AST va être compilé en C++ pour ensuite être compilé en un binaire natif (`.so`) chargé comme plugin et directement exécuté par le processeur. Les gains en performances pourraient être très importants. Cependant, un tel mécanisme n’est intéressant qu’en production : la compilation en binaire sera très lente (plusieurs secondes) car devant invoquer GCC et devra intervir à chaque modification du template (qui est fréquente en développement).

## Fonctionnalités actuelles ##

Dans la version de développement actuelle (branche « `dev` » du dépôt Git), les fonctionnalités suivantes sont implémentées :

  * Exécution requêtes HTTP via FastCGI ;
  * Récupération / envoie d’en-têtes HTTP ;
  * Données `GET` / `POST` ;
  * Cookies (lecture et écriture) ;
  * Sessions (avec association optionnelle de l’adresse IP à la session) ;
  * Parsage du user-agent ;
  * Gestion des exceptions et segfaults ;
  * Profilage du code (temps d’exécution, requêtes SQL, avertissements, etc.) ;
  * Barre de développement en bas de page (à la Symfony) qui affiche les informations de profilage ;
  * Gestion des plugins ;
  * Contrôleurs, actions ;
  * Vues, variables de vues (pour les templates principalement) ;
  * Routeurs, routes (sur contrôleur / action, vue ou fonction), arguments, délégations ;
  * Connexion à un DBMS, exécution de requêtes SQL ;
  * Implémentation de MariaDB (MySQL) ;
  * Classes utilitaires (`String`, `ByteArray`, `Date`, `DateTime`, `List`, `Map`, `MultiMap`, `OrderedMap`, `Pair`, `Stack`, `String`, `StringList`, `Time`, `Variant`, `Chrono`) ;
  * Accès aux fichiers et dossiers (POSIX) ;
  * Expressions régulières (avec PCRE) ;
  * Parsage de fichiers INI (merci Boost) ;
  * Générateur pseudo-aléatoire ;
  * Coloration syntaxique de langages (C++ actuellement implémenté) ;
  * Parsage XML (avec `pugixml`) ;
  * Gestion des processus (non complétée) ;
  * Hashage cryptographique (SHA-256, SHA-384 et SHA-512 actuellement implémentés) ;
  * Gestion des langues, traductions et formats régionaux (nombres, dates, monnaies, …) ;
  * Dates et heures, fuseaux horaires, conversions UTC ↔ heure locale ;
  * Sécurisation des entrées UTF-8 : suppression des séquences UTF-8 invalides (cf. [RFC3629](https://tools.ietf.org/html/rfc3629#section-10)), correction des séquences « overlong », supression de caractères indésirables (`SOH`, `STX`, `ETX`, `EOT`, `ENQ`, …) et remplacement des `CRLF` par `LF` ;
  * Shell de développement.

## Fonctionnalités de la version actuelle (0.1-a1) ##

À la publication de la version actuelle, les fonctionnalités suivantes seront implémentées :

  * Moteur de templates :
    * Blocs if / elseif / else / for / inherit / block ;
    * Expressions :
      * 
    * Compilation native en C++.
  * Révision du système de routage : routeurs YAML, domaines, HTTPS, redirections ;
  * HTTPS / HSTS et certificats client (authentification forte) ;
  * Corrections de certaines fuites de mémoire (très important) ;
  * Portage stable sous *BSD (FreeBSD, OpenBSD, …).

## Fonctionnalités prévues dans des versions futures ##

Dans de futures versions les fonctionnalités suivantes seront implémentées :

  * ORM ;
  * Envoie d’emails ;
  * Formulaires ;
  * Portage expérimental (pour développement seulement) sous Windows ;
  * Thread-safety ;
  * Manager, interface de gestion bas niveau de WebCpp.

# Participer au développement #

WebCpp est un logiciel libre ! Cela sous-entend que vous êtes invités et encouragés à participer au développement du projet de la manière qu’il vout plaît. Mais comment ? Il existe un dépôt Git public disponible à l’adresse <<<adresse Git public>>>, celui-ci est en lecture seule. Clonez-le, effectuez vos modifications en local, comittez puis créer un dépôt accessible publiquement contenant vos comits. Envoyez-moi ensuite l’adresse de ce dépôt public, je le clonerai puis effectuerai moi même l’intégration si j’accepte vos modifications. Je vous conseille d’étudier le code actuel pour que vous saisissiez les différentes normes de codage que j’utilise. Vous trouverez plus d’informations sur les modalités de participation par le code sur la page <http://www.webcpp.org/participate/how-to-code-for-webcpp>. Dans le doute, contactez-moi (<kevin@lesenechal.org>).

Sachez également que je serais intéressé par les services de designers pour le site Web de WebCpp ainsi que l’interface de gestion (le manager) qui sera développée lors de la prochaine version. Il y a également les pages built-ins de WebCpp comme la page affichant une exception survenue qui aurait besoin d’être travaillée. Je n’ai cependant aucune compétence artistique en web design ! C’est pourquoi toute participation sera très appréciée.

# Votre avis m’intéresse ! #

Si je crée ce sujet de présentation c’est avant tout pour vous donner la parole ! Je souhaite recueillir des impressions, des commentaires et des critiques sur mon projet afin de pouvoir l’améliorer. Vos idées et suggestion me permettront de définir les objectifs des futurs versions et de la direction à prendre.